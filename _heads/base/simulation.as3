stop();

if (selectedUnit == "0" || selectedPlan == "0"){
	gotoAndStop(9);
}

var simulationPlan: Array = new Array();
var simulationUnit: Array = new Array();

var simCarLength: Number = 20;
var simCarSpace: Number = 1;
var simCarUnit: Number = simCarLength + simCarSpace;
var simCarWheelFront: Number = 3.7;
var simCarWheelRear: Number = 16.3;
var simCarHeight: Number = 8;


var auxiliaryData: Array = new Array();

var currentSimulationState = "start";
// start
// during
// end

simulation_title.text = "running " + String(selectedUnit) + " on " + String(selectedPlan);

simulation_back_btn.addEventListener(MouseEvent.CLICK, simulation_back);
function simulation_back(event: MouseEvent){
	gotoAndStop(9);
}

simulation_front_btn.addEventListener(MouseEvent.CLICK, simulation_proceed);
function simulation_proceed(event: MouseEvent){
	if (currentSimulationState == "start"){
		currentSimulationState = "during";
		simulation_front_btn.visible = false;
	} else if (currentSimulationState == "during"){
		currentSimulationState = "end";
	} else if (currentSimulationState == "end"){
		gotoAndStop(12);
	}
}

function readSimulationUnit(){
	try {
		var newUnitFile:File = File.documentsDirectory.resolvePath("upRail/units/" + selectedUnit + ".uptrain");
		var fileStream:FileStream = new FileStream();
		fileStream.open(newUnitFile, FileMode.READ);
		var fileContent:String = fileStream.readUTFBytes(fileStream.bytesAvailable);
		fileStream.close();
	} catch (error:Error){
		trace("Could not read file: " + error.message);
		return;
	}
	var fileLines: Array = fileContent.split(/\n/);
	var fileCars: int = int(fileLines[8].slice(6));
	for (var i: int = 0; i < fileCars; i++){
		var nodeLine: Array = fileLines[9 + i].split(' ');
		var readCarMass = int(nodeLine[0]);
		var readCarType = String(nodeLine[1]);
		var readCarTraction = Number(nodeLine[2]);
		var readCarBrake = Number(nodeLine[3]);
		simulationUnit.push([readCarType]);
	}
}

function readSimulationPlan(){
	try {
		var newPlanFile:File = File.documentsDirectory.resolvePath("upRail/plans/" + selectedPlan + ".upmap");
		var fileStream:FileStream = new FileStream();
		fileStream.open(newPlanFile, FileMode.READ);
		var fileContent:String = fileStream.readUTFBytes(fileStream.bytesAvailable);
		fileStream.close();
	} catch (error:Error){
		trace("Could not read file: " + error.message);
		return;
	}
	var fileLines: Array = fileContent.split(/\n/);
	var readNodesCount: int = 0;
	readNodesCount = int(fileLines[2].slice(7));
	for (var nodeIndexCount: int = 0; nodeIndexCount < readNodesCount; nodeIndexCount++){
		var nodeLine: Array = fileLines[3 + nodeIndexCount].split(' ');
		var readNodeX = int(nodeLine[0]);
		var readNodeY = int(nodeLine[1]);
		simulationPlan.push([readNodeX, readNodeY]);
	}
}

function paintSimulationUnit(){
	
}

function paintSimulationPlan(){
	var filling: Shape = new Shape();
	var matrix: Matrix = new Matrix();
	matrix.scale(0.1, 0.1);
	simScreen.addChild(filling);
	filling.graphics.beginBitmapFill(new TrackMap(), matrix, true, true);
	filling.graphics.moveTo(0, 550);
	for (var i: int = 0; i < simulationPlan.length; i++){
		filling.graphics.lineTo(simulationPlan[i][0], 550 - simulationPlan[i][1]);
	}
	filling.graphics.lineTo(1000, 550);
	filling.graphics.endFill();
	filling.alpha = 0.5;
	for (var j: int = 0; j < simulationPlan.length - 1; j++){
		var newSegment: MovieClip = new MovieClip();
		simScreen.addChild(newSegment);
		newSegment.graphics.lineStyle(1, 0x000000);
		newSegment.graphics.moveTo(simulationPlan[j][0], 550 - simulationPlan[j][1]);
		newSegment.graphics.lineTo(simulationPlan[j+1][0], 550 - simulationPlan[j+1][1]);
	}
}

function setAcceleration(acceleration: int){
	simulation_force.gotoAndStop(acceleration + 101)
}
setAcceleration(0);

function setProgress(progress: int){
	if (progress == 0) {
		progress = 1;
	}
	simulation_progress.gotoAndStop(progress);
}
setProgress(1);

function setSimulationDistance(simulationDistance: Number){
	simulation_distance.text = String(int(simulationDistance)) + "m";
}

function setSimulationSpeed(simulationSpeed: Number){
	simulation_speed.text = String(simulationSpeed.toPrecision(1)) + "m/s";
}

function setSimulationAcceleration(simulationAcceleration: Number){
	simulation_acceleration.text = String(simulationAcceleration.toPrecision(1)) + "m/sÂ²";
}

function computeAuxiliaryData(){
	// [isNode, y, leftNode[i,x,y], rightNode[i,x,y], angle]
	//     0    1       2                3              4
	var i: int = 0;
	
	// fill Array
	for (i = 0; i <= 1000; i++){
		auxiliaryData.push([false, 0, [0, 0], [0, 0], 0])
	}

	auxiliaryData[0][0] = true;
	auxiliaryData[0][1] = simulationPlan[0][1];
	auxiliaryData[0][2] = null;
	auxiliaryData[0][3] = [1, simulationPlan[1][0], simulationPlan[1][1]];
	auxiliaryData[0][4] = 0;

	auxiliaryData[1000][0] = true;
	auxiliaryData[1000][1] = simulationPlan[simulationPlan.length - 1][1];
	auxiliaryData[1000][2] = [simulationPlan.length - 2, simulationPlan[simulationPlan.length - 2][0], simulationPlan[simulationPlan.length - 2][1]];
	auxiliaryData[1000][3] = null;
	auxiliaryData[1000][4] = 0;

	// fill leftNode, rightNode and isNode
	var lastAuxNode: int = 0;
	var nextAuxNode: int = 1;
	for (i = 1; i <= 999; i++){
		var currentLeftNode: Array = [0, 0, 0];
		currentLeftNode[0] = lastAuxNode;
		currentLeftNode[1] = simulationPlan[lastAuxNode][0];
		currentLeftNode[2] = simulationPlan[lastAuxNode][1];
		auxiliaryData[i][2] = currentLeftNode;
		
		if (simulationPlan[nextAuxNode][0] == i){
			auxiliaryData[i][0] = true;
			auxiliaryData[i][1] = simulationPlan[nextAuxNode][1];
			lastAuxNode++;
			nextAuxNode++;
		} else {
			auxiliaryData[i][0] = false;
		}
		
		var currentRightNode: Array = [0, 0, 0];
		currentRightNode[0] = nextAuxNode;
		currentRightNode[1] = simulationPlan[nextAuxNode][0];
		currentRightNode[2] = simulationPlan[nextAuxNode][1];
		auxiliaryData[i][2] = currentLeftNode;
		auxiliaryData[i][3] = currentRightNode;
	}
	
	// fill y
	for (i = 1; i <= 999; i++){
		if (!auxiliaryData[i][0]){
			var aauxLeftX: Number = auxiliaryData[i][2][1];
			var aauxLeftY: Number = auxiliaryData[i][2][2];
			var aauxRightX: Number = auxiliaryData[i][3][1];
			var aauxRightY: Number = auxiliaryData[i][3][2];
			var aauxCurrentX: Number = i;
			var t: Number = (aauxCurrentX - aauxLeftX) / (aauxRightX - aauxLeftX);
			var aauxCurrentY:Number = aauxLeftY + t * (aauxRightY - aauxLeftY);
			auxiliaryData[i][1] = aauxCurrentY;
		}
	}

	// fill angle
	for (i = 1; i <= 999; i++){
		var auxLeftX: Number = i - 1;
		var auxLeftY: Number = auxiliaryData[i - 1][1];
		var auxRightX: Number = i + 1;
		var auxRightY: Number = auxiliaryData[i + 1][1];
		auxiliaryData[i][4] = Math.atan2((auxRightY - auxLeftY) , (auxRightX - auxLeftX));
	}
}

function computeDistanceProjection(D: Number, xA: Number, yA: Number, xB: Number, yB: Number){
    var distanceAB: Number = Math.sqrt(Math.pow(xB - xA, 2) + Math.pow(yB - yA, 2));
    var r: Number = D / distanceAB;
    var xN: Number = xA + r * (xB - xA);
    var yN: Number = yA + r * (yB - yA);
    return [xN, yN];
}

function computeDistanceTP(xA: Number, yA: Number, xB: Number, yB: Number){
	var distanceAB: Number = Math.sqrt(Math.pow(xB - xA, 2) + Math.pow(yB - yA, 2));
	return distanceAB;
}

function computeWalkOnTrack(Dist: Number, xA: Number, yA: Number){
	var leftNode: Array = auxiliaryData[xA][2];
	var leftNodeX: Number = leftNode[1];
	var leftNodeY: Number = leftNode[2];
	var leftDistance: Number = Dist;
	while (leftDistance > 0){
		var toNode: Number = computeDistanceTP(xA, yA, leftNodeX, leftNodeY);
		if (leftDistance <= toNode){
			return computeDistanceProjection(leftDistance, xA, yA, leftNodeX, leftNodeY);
		} else {
			leftDistance -= toNode;
			xA = leftNodeX;
			yA = leftNodeY;
			leftNode = auxiliaryData[xA][2];
			leftNodeX = leftNode[1];
			leftNodeY = leftNode[2];
			if (leftNodeX == 0){
				return [leftNodeX, leftNodeY];
			}
		}
	}
}

readSimulationUnit();
readSimulationPlan();
paintSimulationPlan();

computeAuxiliaryData();